use std::collections::HashMap;


use async_trait::async_trait;
use nanoid::nanoid;

#[derive(Eq, Hash, PartialEq, Clone)]
pub struct AgentKey {
    domain: String,
    name: String,
}

impl AgentKey {
    pub fn key(&self) -> String {
        format!("{}:{}", self.domain, self.name)
    }
}

#[derive(Debug)]
pub enum AgentError {
    AgentAlreadyExists,
}

/// # Agent is a struct that represents a running agent.
/// - It contains the agent's key, version, description, and active status.
/// - The key is generated by the AgentManager when the agent is registered.
/// - The version is the version of the agent.
/// - The description is a description of the agent.
/// - The active status is a boolean that indicates whether the agent is active or not.
/// - An active agent is one that is running and can be used to execute tasks.
/// - An inactive agent is one that is not running and cannot be used to execute tasks.
/// - An inactive agent can be activated by the AgentManager.
/// - An active agent can be deactivated by the AgentManager.
/// - An agent can be removed by the AgentManager.
/// - An agent can be updated by the AgentManager.
pub struct Agent {
    key: Option<AgentKey>,
    version: String,
    description: String,
    active: bool,
}

impl Agent {
    pub fn new(version: String, description: String) -> Agent {
        Agent {
            key: None,
            version,
            description,
            active: true,
        }
    }
}

pub struct AgentStore {
    domain: String,
    agents: HashMap<AgentKey, Agent>,
}

impl AgentStore {
    pub fn register(&mut self, agent: Agent) -> AgentKey {
        let key = self.get_next_agent_key();
        self.agents.insert(key.clone(), agent);
        key
    }
}

impl AgentStore {
    pub fn new(domain: String) -> AgentStore {
        AgentStore {
            agents: HashMap::new(),
            domain,
        }
    }

    /// # Calculate the next agent key.
    /// - The agent key is a combination of the domain and a random string.
    /// - The random string is generated using the nanoid crate.
    pub fn get_next_agent_key(&self) -> AgentKey {
        AgentKey {
            domain: self.domain.clone(),
            name: nanoid!(20),
        }
    }
}

#[async_trait]
pub trait AgentManager {
    async fn register(&mut self, agent: Agent) -> Result<AgentKey, AgentError>;
}